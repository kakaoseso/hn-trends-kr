---
title: "PS2 게임을 PC 네이티브로? 에뮬레이션의 끝판왕 PS2Recomp 분석"
description: "PS2 게임을 PC 네이티브로? 에뮬레이션의 끝판왕 PS2Recomp 분석"
pubDate: "2026-01-30T01:22:41Z"
---

솔직히 고백하자면, 엔지니어로서 PlayStation 2(PS2)의 아키텍처를 처음 접했을 때 느꼈던 감정은 경외감보다는 '공포'에 가까웠습니다. MIPS R5900 기반의 Emotion Engine, 두 개의 Vector Unit(VU0, VU1), 그리고 독자적인 Graphics Synthesizer까지. 당시 소니는 하드웨어 설계에서 거의 외계 고문을 통해 얻어낸 듯한 복잡성을 보여줬죠.

그런데 최근 이 복잡한 괴물을 현대적인 x64나 ARM 아키텍처에서 **네이티브** 로 돌리려는 시도가 등장했습니다. 에뮬레이터가 아닙니다. 바로 **정적 재컴파일(Static Recompilation)** 프로젝트인 [PS2Recomp](https://github.com/ran-j/PS2Recomp) 이야기입니다.

오늘은 이 프로젝트가 왜 기술적으로 '미친 짓'인지, 그리고 왜 이것이 게임 보존(Preservation)의 성배(Holy Grail)가 될 수 있는지 엔지니어의 관점에서 뜯어보겠습니다.

## 에뮬레이션 vs 정적 재컴파일: 차원이 다른 접근

우리가 흔히 쓰는 PCSX2 같은 훌륭한 에뮬레이터들은 주로 **JIT(Just-In-Time)** 방식을 사용합니다. 게임이 실행되는 도중에 PS2의 기계어를 실시간으로 현대 CPU의 기계어로 번역하는 방식이죠. 호환성은 좋지만, 번역 오버헤드가 발생하고 하드웨어 스펙을 많이 탑니다.

반면, **PS2Recomp** 가 시도하는 정적 재컴파일은 접근 방식이 완전히 다릅니다.

1.  **바이너리 번역:** PS2 게임의 실행 파일(ELF 등)을 가져와서,
2.  **중간 표현(IR) 변환:** 이를 분석 가능한 중간 코드로 변환하고,
3.  **네이티브 컴파일:** 타겟 플랫폼(Windows, Linux 등)에서 실행 가능한 **독립 실행 파일(Executable)** 로 다시 빌드합니다.

결과물은 더 이상 에뮬레이터 위에서 돌아가는 ROM 파일이 아닙니다. 그냥 내 PC에서 더블 클릭하면 실행되는 `.exe` 파일이 되는 겁니다.

![](https://redgamingtech.com/wp-content/uploads/ps2-console-1024x683.jpg)

## 왜 이것이 'Game Changer'인가?

단순히 실행만 되는 것이라면 PCSX2로도 충분합니다. 하지만 엔지니어링 관점에서 재컴파일이 가지는 잠재력은 어마어마합니다.

- **성능 오버헤드 제거:** 런타임에 명령어를 번역할 필요가 없으니 CPU 부하가 극적으로 줄어듭니다. 저사양 노트북이나 UMPC에서도 PS2 게임을 풀프레임으로 돌릴 수 있게 됩니다.
- **무한한 확장성:** 코드가 네이티브로 변환되었기 때문에, 후킹(Hooking)이나 모딩이 훨씬 쉬워집니다. 단순히 해상도를 올리는 것을 넘어, 울트라 와이드 지원, 고주사율 해제, 심지어 **Ray Tracing** 적용까지 가능해집니다.

이미 우리는 닌텐도 64 진영에서 이 가능성을 확인했습니다. [Mario 64](https://github.com/sm64-port/sm64-port)나 Zelda 64의 네이티브 포팅 프로젝트들이 보여준 결과물은 충격적이었죠. 아래 이미지를 보십시오. 1996년 게임에 실시간 레이트레이싱이 적용된 모습입니다.

![](https://redgamingtech.com/wp-content/uploads/mario-raytracing-1024x576.jpg)

## Hacker News의 반응: "현대 게임에 지친 영혼들"

이 소식을 접한 Hacker News의 반응도 흥미롭습니다. 기술적인 감탄도 있었지만, 의외로 많은 시니어 개발자들이 **"왜 우리가 옛날 게임에 집착하는가?"** 에 대해 토론하고 있더군요.

한 유저는 이렇게 말합니다.
> "현대 게임은 입력 지연(Latency)에 너무 관대하다. NES나 SNES 시절의 그 쫀득한(Twitchy) 조작감이 그립다."

이 지적은 꽤 날카롭습니다. 에뮬레이터는 구조적으로 인풋 랙(Input Lag)을 유발할 수밖에 없는데, 재컴파일을 통한 네이티브 포팅은 이 문제를 하드웨어 수준까지 줄일 수 있는 유일한 대안입니다. 단순히 추억 보정이 아니라, **게임플레이 경험(UX)의 복원** 이라는 측면에서 기술적 가치가 있다는 것이죠.

물론, "요즘 게임은 마이크로트랜잭션 범벅이라 할 게 없다"라는 전형적인 '라떼는 말이야'식 한탄도 많았지만, [Outer Wilds]나 [Hollow Knight] 같은 인디 명작들을 언급하며 현대 게임을 옹호하는 의견들도 균형을 이루고 있었습니다.

## 기술적 난관: 은탄환은 아니다

하지만 냉정하게 엔지니어로서 판단하건대, 이 프로젝트가 당장 모든 PS2 게임을 PC판으로 만들어주지는 못할 겁니다.

- **간접 분기(Indirect Jumps):** 정적 재컴파일러의 주적입니다. 런타임에 결정되는 점프 주소를 정적으로 완벽하게 분석하는 건 결정 불가능(Undecidable) 문제에 가깝습니다.
- **자가 수정 코드(Self-modifying Code):** PS2 게임들이 메모리 절약을 위해 런타임에 코드를 수정하는 트릭을 썼다면, 정적 재컴파일러는 이를 처리하기 매우 까다롭습니다.
- **HLE(High Level Emulation) 의존:** PS2 BIOS나 하드웨어 인터럽트를 완벽하게 재구현해야 합니다.

## 결론: 보존(Preservation)의 미래

PS2Recomp는 아직 초기 단계입니다. 하지만 이 접근 방식은 게임 보존의 패러다임을 바꾸고 있습니다. 에뮬레이터가 '하드웨어를 보존'하는 것이라면, 재컴파일은 '소프트웨어를 해방'시키는 것입니다.

만약 당신이 C++나 시스템 프로그래밍에 관심이 있다면, 이 프로젝트의 [GitHub](https://github.com/ran-j/PS2Recomp)를 들여다보는 것을 추천합니다. 20년 전 소니 엔지니어들의 천재적인(혹은 변태적인) 최적화 기법들과, 그것을 현대적으로 해석하려는 오픈소스 기여자들이 벌이는 두뇌 싸움을 구경하는 것만으로도 주말이 순식간에 지나갈 겁니다.

**References:**
- [Original Article](https://redgamingtech.com/playstation-2-recompilation-project-is-absolutely-incredible/)
- [Hacker News Discussion](https://news.ycombinator.com/item?id=46814743)
